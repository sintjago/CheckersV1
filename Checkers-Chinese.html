<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>跳棋游戏（中文）</title>
  <style>
    body {
      text-align: center;
      font-family: Arial, sans-serif;
    }
    .title {
      font-size: 24px;
      font-weight: bold;
      margin: 20px 0;
    }
    .controls {
      margin-bottom: 10px;
    }
    .controls button {
      margin: 5px;
      padding: 8px 15px;
      font-size: 16px;
    }
    .capture-display {
      margin: 5px 0;
      font-size: 18px;
    }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
    }
    canvas {
      border: 2px solid #333;
      max-width: 90vw;
      height: auto;
    }
    #instructions {
      font-size: 16px;
      margin-top: 15px;
      margin-bottom: 10px;
      white-space: pre-line;
      max-width: 440px;
    }
    .tracking-table {
      width: 100%;
      max-width: 440px;
      margin: 0 auto;
      border-collapse: collapse;
      table-layout: auto;
    }
    .tracking-table, .tracking-table th, .tracking-table td {
      border: 1px solid #ccc;
    }
    .tracking-table th, .tracking-table td {
      padding: 5px;
      text-align: center;
      word-wrap: break-word;
    }
    th {
      background-color: #f2f2f2;
    }
  </style>
</head>
<body>

  <div class="title">跳棋游戏（中文）</div>

  <div class="controls">
    <button onclick="undoMove()">撤销</button>
    <button onclick="resetBoard()">重置</button>
    <button onclick="toggleSound()" id="soundToggle">声音：开启</button>
  </div>

  <div class="capture-display">被吃子 - 白方: <span id="whiteCaptured">0</span> | 黑方: <span id="blackCaptured">0</span></div>

  <div class="game-container">
    <canvas id="checkersboard"></canvas>

    <p id="instructions">
      点击并拖动棋子进行移动。吃子自动完成。
      如果可以连跳，必须完成连跳。
    </p>

    <table class="tracking-table">
      <thead>
        <tr>
          <th>玩家</th>
          <th>移动</th>
          <th>棋子</th>
          <th>被吃</th>
        </tr>
      </thead>
      <tbody id="moveTracking"></tbody>
    </table>
  </div>

  <script>
    const canvas = document.getElementById('checkersboard');
    const ctx = canvas.getContext('2d');
    const boardSize = 8;
    const squarePadding = 20;
    let squareSize;
    let whiteCaptured = 0;
    let blackCaptured = 0;
    let soundEnabled = true;
    let selectedSquare = null;
    let selectedPiece = null;
    let currentPlayer = 'R';
    let mustContinueJump = false;

    const blue = "#00274C";
    const yellow = "#FFCB05";
    const gold = "#FFD700";
    const synth = window.speechSynthesis;

    const hanzi = '日月山水火田人心文生学中大国天气花树鱼鸟马车书笔电手足头面'.split('');
    let pieceLetters = {};
    let gameHistory = [];
    let moveList = document.getElementById('moveTracking');

    const initialBoard = [
      ["", "B", "", "B", "", "B", "", "B"],
      ["B", "", "B", "", "B", "", "B", ""],
      ["", "B", "", "B", "", "B", "", "B"],
      ["", "", "", "", "", "", "", ""],
      ["", "", "", "", "", "", "", ""],
      ["R", "", "R", "", "R", "", "R", ""],
      ["", "R", "", "R", "", "R", "", "R"],
      ["R", "", "R", "", "R", "", "R", ""]
    ];

    let board = JSON.parse(JSON.stringify(initialBoard));

    function resizeCanvas() {
      canvas.width = Math.min(window.innerWidth * 0.9, 400);
      canvas.height = canvas.width;
      squareSize = (canvas.width - 2 * squarePadding) / boardSize;
      drawBoard();
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function assignLetters() {
      let index = 0;
      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          if (board[row][col] !== "") {
            pieceLetters[`${row},${col}`] = hanzi[index % hanzi.length];
            index++;
          }
        }
      }
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = "16px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          ctx.fillStyle = (row + col) % 2 === 0 ? yellow : blue;
          ctx.fillRect(col * squareSize + squarePadding, row * squareSize + squarePadding, squareSize, squareSize);

          if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col) {
            ctx.fillStyle = "rgba(255, 215, 0, 0.5)";
            ctx.fillRect(col * squareSize + squarePadding, row * squareSize + squarePadding, squareSize, squareSize);
          }

          const piece = board[row][col];
          if (piece && !(selectedSquare && selectedSquare.row === row && selectedSquare.col === col)) {
            const isKing = piece === "RK" || piece === "BK";
            const color = piece.startsWith("B") ? '#000' : '#FFF';
            const rimColor = piece.startsWith("B") ? '#FFF' : '#000';
            const letter = pieceLetters[`${row},${col}`];

            const chipMargin = 6;
            ctx.beginPath();
            ctx.arc(col * squareSize + squareSize / 2 + squarePadding, row * squareSize + squareSize / 2 + squarePadding, squareSize / 2 - chipMargin, 0, Math.PI * 2);
            ctx.fillStyle = rimColor;
            ctx.fill();

            ctx.beginPath();
            ctx.arc(col * squareSize + squareSize / 2 + squarePadding, row * squareSize + squareSize / 2 + squarePadding, squareSize / 2 - chipMargin - 2, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();

            ctx.font = isKing ? "bold 20px Arial" : "20px Arial";
            ctx.lineWidth = isKing ? 2 : 1;
            ctx.strokeStyle = "black";
            ctx.strokeText(letter, col * squareSize + squareSize / 2 + squarePadding, row * squareSize + squareSize / 2 + squarePadding);
            ctx.fillStyle = isKing ? gold : rimColor;
            ctx.fillText(letter, col * squareSize + squareSize / 2 + squarePadding, row * squareSize + squareSize / 2 + squarePadding);
          }
        }
      }
    }

    function playLetterSound(letter) {
      if (soundEnabled && letter) {
        synth.cancel();
        const utter = new SpeechSynthesisUtterance(letter);
        utter.lang = 'zh-CN';
        synth.speak(utter);
      }
    }

    function speak(text) {
      if (soundEnabled) {
        synth.cancel();
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = 'zh-CN';
        synth.speak(utter);
      }
    }

    function toggleSound() {
      soundEnabled = !soundEnabled;
      document.getElementById('soundToggle').textContent = `声音：${soundEnabled ? '开启' : '关闭'}`;
    }

    function getPlayerName(piece) {
      return (piece.includes("K") ? "王 " : "") + (piece.startsWith("B") ? "黑方" : "白方");
    }

    function promoteToKing(row, piece, letter) {
      if ((piece === 'R' && row === 0) || (piece === 'B' && row === 7)) {
        speak(`王 升级 ${letter}`);
        return piece + "K";
      }
      return piece;
    }

    function trackMove(player, fromRow, fromCol, toRow, toCol, movedLetter, capturedLetter = "") {
      const from = `${fromCol},${fromRow}`;
      const to = `${toCol},${toRow}`;
      const row = moveList.insertRow();
      row.insertCell(0).textContent = player;

      const moveCell = row.insertCell(1);
      moveCell.textContent = `${from} → ${to}`;
      moveCell.addEventListener("click", () => playLetterSound(movedLetter));

      const pieceCell = row.insertCell(2);
      pieceCell.textContent = movedLetter;
      pieceCell.addEventListener("click", () => playLetterSound(movedLetter));

      const capturedCell = row.insertCell(3);
      capturedCell.textContent = capturedLetter;
      if (capturedLetter) {
        capturedCell.addEventListener("click", () => playLetterSound(capturedLetter));
        speak(`吃子 ${capturedLetter}`);
      }
    }

    function saveState() {
      gameHistory.push({
        board: JSON.parse(JSON.stringify(board)),
        whiteCaptured,
        blackCaptured,
        currentPlayer
      });
    }

    function undoMove() {
      if (gameHistory.length > 0) {
        const prev = gameHistory.pop();
        board = JSON.parse(JSON.stringify(prev.board));
        whiteCaptured = prev.whiteCaptured;
        blackCaptured = prev.blackCaptured;
        currentPlayer = prev.currentPlayer;
        moveList.deleteRow(moveList.rows.length - 1);
        updateCaptureDisplay();
        drawBoard();
      }
    }

    function resetBoard() {
      board = JSON.parse(JSON.stringify(initialBoard));
      whiteCaptured = 0;
      blackCaptured = 0;
      gameHistory = [];
      moveList.innerHTML = "";
      currentPlayer = 'R';
      assignLetters();
      updateCaptureDisplay();
      drawBoard();
    }

    function updateCaptureDisplay() {
      document.getElementById('whiteCaptured').textContent = whiteCaptured;
      document.getElementById('blackCaptured').textContent = blackCaptured;
    }

    function hasAdditionalJump(row, col, piece) {
      const dirs = [[-2, -2], [-2, 2], [2, -2], [2, 2]];
      for (let [dr, dc] of dirs) {
        const nr = row + dr;
        const nc = col + dc;
        const mr = row + dr / 2;
        const mc = col + dc / 2;
        if (
          nr >= 0 && nr < 8 && nc >= 0 && nc < 8 &&
          board[nr][nc] === "" &&
          board[mr][mc] &&
          board[mr][mc][0] !== piece[0]
        ) return true;
      }
      return false;
    }

    function getEventPosition(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    }

    canvas.addEventListener('mousedown', e => {
      const { x, y } = getEventPosition(e);
      const col = Math.floor((x - squarePadding) / squareSize);
      const row = Math.floor((y - squarePadding) / squareSize);
      const piece = board[row]?.[col];
      if (piece && piece.startsWith(currentPlayer)) {
        selectedSquare = { row, col };
        selectedPiece = piece;
        playLetterSound(pieceLetters[`${row},${col}`]);
      }
    });

    canvas.addEventListener('mouseup', e => {
      const { x, y } = getEventPosition(e);
      const col = Math.floor((x - squarePadding) / squareSize);
      const row = Math.floor((y - squarePadding) / squareSize);
      if (selectedSquare && isMoveValid(row, col)) {
        saveState();
        handlePiecePlacement(row, col);
      }
      selectedSquare = null;
      selectedPiece = null;
      drawBoard();
    });

    function isMoveValid(row, col) {
      if (!selectedSquare || board[row][col]) return false;
      const rowDiff = row - selectedSquare.row;
      const colDiff = col - selectedSquare.col;
      if (Math.abs(rowDiff) === 1 && Math.abs(colDiff) === 1 && !mustContinueJump) return true;
      if (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 2) {
        const midRow = (row + selectedSquare.row) / 2;
        const midCol = (col + selectedSquare.col) / 2;
        const jumped = board[midRow][midCol];
        return jumped && jumped[0] !== selectedPiece[0];
      }
      return false;
    }

    function handlePiecePlacement(row, col) {
      const { row: sr, col: sc } = selectedSquare;
      const rowDiff = row - sr;
      const colDiff = col - sc;
      const midRow = (row + sr) / 2;
      const midCol = (col + sc) / 2;
      const jumpedPiece = board[midRow]?.[midCol];
      const movingLetter = pieceLetters[`${sr},${sc}`];

      if (Math.abs(rowDiff) === 1 && Math.abs(colDiff) === 1 && !mustContinueJump) {
        board[row][col] = promoteToKing(row, selectedPiece, movingLetter);
        board[sr][sc] = "";
        pieceLetters[`${row},${col}`] = movingLetter;
        delete pieceLetters[`${sr},${sc}`];
        trackMove(getPlayerName(selectedPiece), sr, sc, row, col, movingLetter);
        currentPlayer = currentPlayer === 'R' ? 'B' : 'R';
      } else if (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 2 && jumpedPiece && jumpedPiece[0] !== selectedPiece[0]) {
        board[row][col] = promoteToKing(row, selectedPiece, movingLetter);
        board[sr][sc] = "";
        board[midRow][midCol] = "";
        if (jumpedPiece[0] === "B") blackCaptured++;
        else whiteCaptured++;
        pieceLetters[`${row},${col}`] = movingLetter;
        trackMove(getPlayerName(selectedPiece), sr, sc, row, col, movingLetter, pieceLetters[`${midRow},${midCol}`]);
        delete pieceLetters[`${sr},${sc}`];
        delete pieceLetters[`${midRow},${midCol}`];
        updateCaptureDisplay();
        if (hasAdditionalJump(row, col, selectedPiece)) {
          selectedSquare = { row, col };
          selectedPiece = board[row][col];
          mustContinueJump = true;
          return;
        } else {
          mustContinueJump = false;
          currentPlayer = currentPlayer === 'R' ? 'B' : 'R';
        }
      }
    }

    assignLetters();
    drawBoard();
  </script>

</body>
</html>
