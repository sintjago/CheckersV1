<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dames en Français</title>
  <style>
    body {
      text-align: center;
      font-family: Arial, sans-serif;
    }
    .title {
      font-size: 24px;
      font-weight: bold;
      margin: 20px 0;
    }
    .controls {
      margin-bottom: 10px;
    }
    .controls button {
      margin: 5px;
      padding: 8px 15px;
      font-size: 16px;
    }
    .capture-display {
      margin: 5px 0;
      font-size: 18px;
    }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
    }
    canvas {
      border: 2px solid #333;
      max-width: 90vw;
      height: auto;
    }
    #instructions {
      font-size: 16px;
      margin-top: 15px;
      margin-bottom: 10px;
      white-space: pre-line;
      max-width: 440px;
    }
    .tracking-table {
      width: 100%;
      max-width: 440px;
      margin: 0 auto;
      border-collapse: collapse;
      table-layout: auto;
    }
    .tracking-table, .tracking-table th, .tracking-table td {
      border: 1px solid #ccc;
    }
    .tracking-table th, .tracking-table td {
      padding: 5px;
      text-align: center;
      word-wrap: break-word;
    }
    th {
      background-color: #f2f2f2;
    }
  </style>
</head>
<body>

  <div class="title">Dames en Français</div>

  <div class="controls">
    <button onclick="undoMove()">Annuler</button>
    <button onclick="resetBoard()">Réinitialiser</button>
    <button onclick="toggleSound()" id="soundToggle">Son : Activé</button>
  </div>

  <div class="capture-display">Pions capturés - Blanc : <span id="whiteCaptured">0</span> | Noir : <span id="blackCaptured">0</span></div>

  <div class="game-container">
    <canvas id="checkersboard"></canvas>

    <p id="instructions">
      Cliquez et faites glisser pour déplacer les pions. Les captures sont automatiques.
      Les sauts multiples sont obligatoires s'ils sont disponibles.
    </p>

    <table class="tracking-table">
      <thead>
        <tr>
          <th>Joueur</th>
          <th>Mouvement</th>
          <th>Pion</th>
          <th>Capturé</th>
        </tr>
      </thead>
      <tbody id="moveTracking"></tbody>
    </table>
  </div>

<!-- JS begins below -->
<script>
  const frenchAlphabet = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z À Â Ä Ç É È Ê Ë Î Ï Ô Ö Ù Û Ü Ÿ'.split(' ');
  const totalPieces = 24 * 2;
  let assignedLetters = frenchAlphabet.sort(() => 0.5 - Math.random()).slice(0, totalPieces);
  let letterIndex = 0;

  const canvas = document.getElementById('checkersboard');
  const ctx = canvas.getContext('2d');
  const boardSize = 8;
  const squarePadding = 20;
  let squareSize;
  let whiteCaptured = 0;
  let blackCaptured = 0;
  let soundEnabled = true;
  let selectedSquare = null;
  let selectedPiece = null;
  let currentPlayer = 'R';
  let mustContinueJump = false;
  let pieceLetters = {};
  let gameHistory = [];
  const moveList = document.getElementById('moveTracking');
  const synth = window.speechSynthesis;

  const initialBoard = [
    ["", "B", "", "B", "", "B", "", "B"],
    ["B", "", "B", "", "B", "", "B", ""],
    ["", "B", "", "B", "", "B", "", "B"],
    ["", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", ""],
    ["R", "", "R", "", "R", "", "R", ""],
    ["", "R", "", "R", "", "R", "", "R"],
    ["R", "", "R", "", "R", "", "R", ""]
  ];

  let board = JSON.parse(JSON.stringify(initialBoard));

  function resizeCanvas() {
    canvas.width = Math.min(window.innerWidth * 0.9, 400);
    canvas.height = canvas.width;
    squareSize = (canvas.width - 2 * squarePadding) / boardSize;
    drawBoard();
  }

  function assignLetters() {
    letterIndex = 0;
    pieceLetters = {};
    for (let row = 0; row < boardSize; row++) {
      for (let col = 0; col < boardSize; col++) {
        if (board[row][col] !== "") {
          pieceLetters[`${row},${col}`] = assignedLetters[letterIndex++ % assignedLetters.length];
        }
      }
    }
  }

  function speak(text) {
    if (soundEnabled) {
      synth.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'fr-FR';
      synth.speak(utterance);
    }
  }

  function playLetterSound(letter) {
    if (soundEnabled && letter) {
      speak(letter);
    }
  }

  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.font = "16px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    for (let row = 0; row < boardSize; row++) {
      for (let col = 0; col < boardSize; col++) {
        ctx.fillStyle = (row + col) % 2 === 0 ? "#FFCB05" : "#00274C";
        ctx.fillRect(col * squareSize + squarePadding, row * squareSize + squarePadding, squareSize, squareSize);

        if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col) {
          ctx.fillStyle = "rgba(255, 215, 0, 0.5)";
          ctx.fillRect(col * squareSize + squarePadding, row * squareSize + squarePadding, squareSize, squareSize);
        }

        const piece = board[row][col];
        if (piece) {
          const isKing = piece === "RK" || piece === "BK";
          const color = piece.startsWith("B") ? '#000' : '#FFF';
          const rimColor = piece.startsWith("B") ? '#FFF' : '#000';
          const letter = pieceLetters[`${row},${col}`];
          const chipMargin = 6;

          ctx.beginPath();
          ctx.arc(col * squareSize + squareSize / 2 + squarePadding, row * squareSize + squareSize / 2 + squarePadding, squareSize / 2 - chipMargin, 0, Math.PI * 2);
          ctx.fillStyle = rimColor;
          ctx.fill();

          ctx.beginPath();
          ctx.arc(col * squareSize + squareSize / 2 + squarePadding, row * squareSize + squareSize / 2 + squarePadding, squareSize / 2 - chipMargin - 2, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();

          ctx.font = isKing ? "bold 20px Arial" : "20px Arial";
          ctx.strokeStyle = "black";
          ctx.lineWidth = isKing ? 2 : 1;
          ctx.strokeText(letter, col * squareSize + squareSize / 2 + squarePadding, row * squareSize + squareSize / 2 + squarePadding);
          ctx.fillStyle = isKing ? "#FFD700" : rimColor;
          ctx.fillText(letter, col * squareSize + squareSize / 2 + squarePadding, row * squareSize + squareSize / 2 + squarePadding);
        }
      }
    }
  }
  function getPlayerName(piece) {
    return (piece.includes("K") ? "Roi " : "") + (piece.startsWith("B") ? "Noir" : "Blanc");
  }

  function promoteToKing(row, piece, letter) {
    if ((piece === 'R' && row === 0) || (piece === 'B' && row === 7)) {
      speak(`couronnement ${letter}`);
      return piece + "K";
    }
    return piece;
  }

  function trackMove(player, fromRow, fromCol, toRow, toCol, movedLetter, capturedLetter = "") {
    const from = `${fromCol},${fromRow}`;
    const to = `${toCol},${toRow}`;
    const row = moveList.insertRow();
    row.insertCell(0).textContent = player;

    const moveCell = row.insertCell(1);
    moveCell.textContent = `${from} à ${to}`;
    moveCell.addEventListener("click", () => playLetterSound(movedLetter));

    const pieceCell = row.insertCell(2);
    pieceCell.textContent = movedLetter;
    pieceCell.addEventListener("click", () => playLetterSound(movedLetter));

    const capturedCell = row.insertCell(3);
    capturedCell.textContent = capturedLetter;
    if (capturedLetter) {
      capturedCell.addEventListener("click", () => playLetterSound(capturedLetter));
      speak(`capture ${capturedLetter}`);
    }
  }

  function updateCaptureDisplay() {
    document.getElementById('whiteCaptured').textContent = whiteCaptured;
    document.getElementById('blackCaptured').textContent = blackCaptured;
  }

  function saveState() {
    gameHistory.push({
      board: JSON.parse(JSON.stringify(board)),
      whiteCaptured,
      blackCaptured,
      currentPlayer
    });
  }

  function undoMove() {
    if (gameHistory.length > 0) {
      const previous = gameHistory.pop();
      board = JSON.parse(JSON.stringify(previous.board));
      whiteCaptured = previous.whiteCaptured;
      blackCaptured = previous.blackCaptured;
      currentPlayer = previous.currentPlayer;
      moveList.deleteRow(moveList.rows.length - 1);
      updateCaptureDisplay();
      drawBoard();
    }
  }

  function resetBoard() {
    board = JSON.parse(JSON.stringify(initialBoard));
    whiteCaptured = 0;
    blackCaptured = 0;
    gameHistory = [];
    moveList.innerHTML = "";
    currentPlayer = 'R';
    assignedLetters = frenchAlphabet.sort(() => 0.5 - Math.random()).slice(0, totalPieces);
    assignLetters();
    updateCaptureDisplay();
    drawBoard();
  }

  function isMoveValid(row, col) {
    if (!selectedSquare || board[row][col]) return false;
    const sr = selectedSquare.row;
    const sc = selectedSquare.col;
    const piece = board[sr][sc];
    const rowDiff = row - sr;
    const colDiff = col - sc;
    if (Math.abs(rowDiff) === 1 && Math.abs(colDiff) === 1 && !mustContinueJump) return true;
    if (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 2) {
      const midRow = (row + sr) / 2;
      const midCol = (col + sc) / 2;
      const jumped = board[midRow]?.[midCol];
      return jumped && jumped[0] !== piece[0];
    }
    return false;
  }

  function hasAdditionalJump(row, col, piece) {
    const directions = [[-2, -2], [-2, 2], [2, -2], [2, 2]];
    for (const [dr, dc] of directions) {
      const newRow = row + dr;
      const newCol = col + dc;
      const midRow = row + dr / 2;
      const midCol = col + dc / 2;
      if (
        newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8 &&
        board[newRow][newCol] === "" &&
        board[midRow][midCol] && board[midRow][midCol][0] !== piece[0]
      ) {
        return true;
      }
    }
    return false;
  }

  function handlePiecePlacement(row, col) {
    const sr = selectedSquare.row;
    const sc = selectedSquare.col;
    const midRow = (sr + row) / 2;
    const midCol = (sc + col) / 2;
    const piece = board[sr][sc];
    const jumped = board[midRow]?.[midCol];
    const isCapture = Math.abs(row - sr) === 2 && jumped && jumped[0] !== piece[0];
    const movingLetter = pieceLetters[`${sr},${sc}`];

    board[row][col] = promoteToKing(row, piece, movingLetter);
    board[sr][sc] = "";
    pieceLetters[`${row},${col}`] = movingLetter;
    delete pieceLetters[`${sr},${sc}`];

    if (isCapture) {
      if (jumped[0] === "B") blackCaptured++;
      else whiteCaptured++;
      board[midRow][midCol] = "";
      const capturedLetter = pieceLetters[`${midRow},${midCol}`];
      delete pieceLetters[`${midRow},${midCol}`];
      updateCaptureDisplay();
      trackMove(getPlayerName(piece), sr, sc, row, col, movingLetter, capturedLetter);
      if (hasAdditionalJump(row, col, piece)) {
        selectedSquare = { row, col };
        selectedPiece = board[row][col];
        mustContinueJump = true;
        drawBoard();
        return;
      }
    } else {
      trackMove(getPlayerName(piece), sr, sc, row, col, movingLetter);
    }

    mustContinueJump = false;
    currentPlayer = currentPlayer === 'R' ? 'B' : 'R';
    drawBoard();
  }

  function getEventPosition(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }

  canvas.addEventListener('mousedown', e => {
    const { x, y } = getEventPosition(e);
    const col = Math.floor((x - squarePadding) / squareSize);
    const row = Math.floor((y - squarePadding) / squareSize);
    if (board[row]?.[col] && board[row][col].startsWith(currentPlayer)) {
      selectedSquare = { row, col };
      selectedPiece = board[row][col];
      playLetterSound(pieceLetters[`${row},${col}`]);
    }
  });

  canvas.addEventListener('mouseup', e => {
    const { x, y } = getEventPosition(e);
    const col = Math.floor((x - squarePadding) / squareSize);
    const row = Math.floor((y - squarePadding) / squareSize);
    if (selectedSquare && isMoveValid(row, col)) {
      saveState();
      handlePiecePlacement(row, col);
    }
    selectedSquare = null;
    selectedPiece = null;
  });

  resizeCanvas();
  assignLetters();
  drawBoard();
</script>
</body>
</html>
